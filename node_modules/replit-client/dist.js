"use strict";

var XMLHttpRequest = require("xmlhttprequest").XMLHttpRequest
var _prototypeProperties = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var _get = function get(object, property, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    return desc.value;
  } else {
    var getter = desc.get;
    if (getter === undefined) {
      return undefined;
    }
    return getter.call(receiver);
  }
};

var _inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) subClass.__proto__ = superClass;
};

/* @flow */

var Promise = require("bluebird");
var EventEmitter = require("events").EventEmitter;

var RETRIES = 7;
var DELAY = 500;
var LANG_EXTS = {
  python: "py",
  ruby: "rb",
  php: "php",
  python3: "py",
  nodejs: "js",
  go: "go",
  java: "java",
  cpp: "cpp",
  cpp11: "cpp",
  c: "c",
  csharp: "cs",
  fsharp: "fs",
  rust: "rs",
  swift: "swift" };

/*:: type stdout = (output: string) => any*/
/*:: type msg = {data: ?string; error: ?string; command: string; }*/
/*:: type file = {content: string; name: string }*/

var ReplitClient = (function (EventEmitter) {
  /*:: _host: string; */
  /*:: _port: string; */
  /*:: _language: string; */
  /*:: _authToken: string; */
  /*:: _authFailed: boolean; */
  /*:: _retries: number; */
  /*:: _ws: any; */
  /*:: _stdout: ?stdout; */
  /*:: _msgQueue: Array<msg>; */
  /*:: _msgResolvers: Array<function>; */
  /*:: _connecting: ?Promise; */
  /*:: _evalConnecting: ?Promise; */
  /*:: _pingTimer: number; */
  /*:: _socketCreator: ?function; */
  /*:: _timeout: number; */
  /*:: _handshakeRetries: number; */

  function ReplitClient(host, /*: string*/port, /*: string*/language, /*: string*/authToken, /*: { msg_mac: string; time_created: number; }*/socketCreator, /*: function*/options /*: { timeout: number; }*/
  ) {
    _get(Object.getPrototypeOf(ReplitClient.prototype), "constructor", this).call(this);
    this._host = host;
    this._port = port;
    this._language = language;
    this._authToken = authToken.time_created + ":" + authToken.msg_mac;
    this._init();
    this._retries = RETRIES;
    this._handshakeRetries = RETRIES;
    this._socketCreator = socketCreator;
    if (options != null) {
      this._timeout = options.timeout;
    }
  }

  _inherits(ReplitClient, EventEmitter);

  _prototypeProperties(ReplitClient, null, {
    connect: {
      value: function connect() /*: Promise<ReplitClient>*/{
        if (this._connecting) {
          return this._connecting;
        }

        this._connecting = this._connect();
        return this._connecting;
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    disconnect: {
      value: function disconnect() /*: Promise<bool>*/{
        var _this = this;
        if (!(this._ws && this._ws.readyState === this._ws.OPEN)) {
          return Promise.resolve(true);
        }

        clearTimeout(this._pingTimer);
        return new Promise(function (resolve) {
          _this._ws.onclose = function () {
            return resolve(true);
          };
          _this._ws.close();
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    write: {
      value: function write(str /*: string*/) {
        var _this2 = this;
        if (!this._evalConnecting) {
          return Promise.reject(new Error("Must evaluate before writing"));
        }
        return this._evalConnecting.then(function () {
          _this2._sendMessage("input", str);
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    evaluate: {
      value: function evaluate(code, /*: string*/_ref) /*: Promise<{
                                                        error: ?string;
                                                        data: ?string;
                                                        }>*/
      {
        var _this3 = this;
        var stdout = _ref.stdout;
        this._evalConnecting = this._connectOrTry();
        return this._evalConnecting.then(function () {
          _this3._stdout = stdout;
          _this3._sendMessage("eval", code);
          return _this3._waitForResult();
        }).then(function (result) {
          _this3._evalConnecting = null;
          return result;
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    lint: {
      value: function lint(code /*: string*/) /*: Promise<{
                                               error: ?string;
                                               data: ?string;
                                               }>*/
      {
        var _this4 = this;
        this._evalConnecting = this._connectOrTry();
        return this._evalConnecting.then(function () {
          _this4._sendMessage("lint", code);
          return _this4._waitForResult();
        }).then(function (result) {
          _this4._evalConnecting = null;
          // Data is an array of warnings/errors
          result.data = JSON.parse(result.data);
          return result;
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    evaluateOnce: {
      value: function evaluateOnce(code, /*: string*/options /*: ?{
                                                             stdout: ?stdout,
                                                             timeout: ?{
                                                             time: number,
                                                             callback: () => bool
                                                             }
                                                             }*/
      ) /*: Promise<{
         error: ?string;
         data: ?string;
         }>*/
      {
        var _this5 = this;
        return new Promise(function (resolve, reject) {
          var req = new XMLHttpRequest();

          var t = null;
          if (options != null && options.timeout) {
            var callback;
            (function () {
              var timeout = options.timeout;
              callback = function () {
                // this is just to make flow happy
                var stop = timeout.callback();
                if (stop) {
                  req.abort();
                  reject(new Error("Aborted"));
                } else {
                  t = setTimeout(callback, timeout.time);
                }
              };

              t = setTimeout(callback, timeout.time);
            })();
          }

          req.onload = function () {
            if (req.status !== 200) {
              clearTimeout(t);
              reject(new Error(req.responseText));
            } else {
              var data /*: Array<msg>*/ = [];
              try {
                data = JSON.parse(req.responseText);
              } catch (e) {
                clearTimeout(t);
                reject(new Error("Error parsing response"));
                return;
              }
              data.forEach(function (msg) {
                if (msg.command === "output") {
                  if (options && options.stdout != null) {
                    options.stdout(msg.data);
                  }
                } else if (msg.command === "result") {
                  clearTimeout(t);
                  resolve(msg);
                }
              });
            }
          };

          var protocol = "http";
          var port = _this5._port;
          if (typeof location === "object" && location.protocol === "https:") {
            protocol = "https";
            if (port === 80 || port === "80") {
              port = 443;
            }
          }

          req.open("POST", protocol + "://" + _this5._host + ":" + port + "/eval", true);

          req.setRequestHeader("Content-Type", "application/x-www-form-urlencoded; param=value");

          var data = "";
          data += "auth=" + encodeURIComponent(_this5._authToken);
          data += "&language=" + encodeURIComponent(_this5._language);
          data += "&code=" + encodeURIComponent(code);

          req.send(data);
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _waitUntilReady: {
      value: function WaitUntilReady() {
        var _this6 = this;
        return this._nextMessage().then(function (msg) {
          if (msg.command === "ready") {
            return msg;
          }

          return _this6._waitUntilReady();
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    stop: {
      value: function stop() /*: Promise*/{
        return this._reset("stop");
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    reset: {
      value: function reset() /*: Promise*/{
        return this._reset("reset");
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _reset: {
      value: function Reset(message /*: string*/) /*: Promise*/{
        var _this7 = this;
        return this._connectOrTry().then(function () {
          var resolver;
          while (resolver = _this7._msgResolvers.shift()) {
            resolver({ command: "skip" });
          }
          _this7._sendMessage(message);
          return _this7._waitUntilReady();
        }).then(function (msg) {
          if (msg.command !== "ready") {
            throw new Error("Expected ready after reset");
          }
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    runProject: {
      value: function runProject(files, /*: Array<file>*/_ref2) /*: Promise<{
                                                                   error: ?string;
                                                                   data: ?string;
                                                                   }>*/
      {
        var _this8 = this;
        var stdout = _ref2.stdout;
        this._evalConnecting = this.reset();
        return this._evalConnecting.then(function () {
          _this8._stdout = stdout;
          // Need to stringify files because 'data' field is expected
          // to be string and not array.
          _this8._sendMessage("runProject", JSON.stringify(files));
          return _this8._waitForResult();
        }).then(function (result) {
          _this8._evalConnecting = null;
          return result;
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    runUnitTests: {
      value: function runUnitTests(_ref3) /*:
                                          Promise<{
                                          error: ?string;
                                          passed: bool;
                                          failures: Array<{ name: string; stack: string; }>;
                                          }>
                                          */{
        var _this9 = this;
        var files = _ref3.files;
        var suiteCode = _ref3.suiteCode;
        this._evalConnecting = this.reset();
        return this._evalConnecting.then(function () {
          // Need to stringify files because 'data' field is expected
          // to be string and not array.
          _this9._sendMessage("runUnitTests", JSON.stringify({
            files: files,
            suiteCode: suiteCode }));
          return _this9._waitForResult();
        }).then(function (result) {
          _this9._evalConnecting = null;
          var data;
          if (result.data) {
            data = JSON.parse(result.data);
          } else {
            data = { passed: false, failures: [] };
          }
          return {
            passed: data.passed,
            failures: data.failures,
            error: result.error };
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    runSingleUnitTests: {
      value: function runSingleUnitTests(_ref4) {
        var code = _ref4.code;
        var suiteCode = _ref4.suiteCode;
        var files = [{
          name: (this._language === "java" ? "Main" : "main") + "." + LANG_EXTS[this._language],
          content: code }];

        return this.runUnitTests({
          files: files,
          suiteCode: suiteCode });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    debug: {
      value: function debug(code, /*: string*/_ref5) /*: Debugger */{
        var stdout = _ref5.stdout;
        this._evalConnecting = this.reset();
        this._stdout = stdout;

        return new Debugger(this, code);
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _init: {
      value: function Init() {
        this._ws = null;
        this._stdout = null;

        this._msgQueue = [];
        this._msgResolvers = [];
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _nextMessage: {
      value: function NextMessage() /*: Promise*/{
        var _this10 = this;
        return new Promise(function (resolve) {
          if (_this10._msgQueue.length) {
            resolve(_this10._msgQueue.shift());
          } else {
            _this10._msgResolvers.push(resolve);
          }
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _connectOrTry: {

      // This will make sure we at least try to connect
      // and not get stuck in some past error.
      // use case is what if we were disconnected from the internet
      // and now we are connected.
      value: function ConnectOrTry() /*: Promise<ReplitClient> */{
        var _this11 = this;
        return this.connect()["catch"](function () {
          _this11._connecting = null;
          return _this11.connect();
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _handshakeRetry: {
      value: function HandshakeRetry(resolve, /*: function */reject /*: function */) {
        this._init();
        this._handshakeRetries -= 1;

        if (this._handshakeRetries < 1) {
          return reject(new HandshakeError("Handshake error"));
        }

        this._connect().then(resolve, reject);
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _connect: {
      value: function Connect() /*: Promise<ReplitClient>*/{
        var _this12 = this;
        return new Promise(function (resolve, reject) {
          _this12.emit("connecting");

          var protocol = "ws";
          var port = _this12._port;
          if (typeof location === "object" && location.protocol === "https:") {
            protocol = "wss";
            if (port === 80 || port === "80") {
              port = 443;
            }
          }

          var url = protocol + "://" + _this12._host + ":" + port + "/ws";
          _this12._ws = _this12._socketCreator ? _this12._socketCreator(url) : new WebSocket(url);

          var timedout = false;
          var timer;
          if (_this12._timeout) {
            timer = setTimeout(function () {
              timedout = true;
              var err = new TimeoutError("Timed out on connecting");
              reject(err);
              _this12.disconnect();
            }, _this12._timeout);
          }

          _this12._ws.onopen = function () {
            _this12._ws.onclose = _this12._handshakeRetry.bind(_this12, resolve, reject);

            // TODO: if we disconnect in a handshake (e.g. faulty server) we should
            // have retry logic.
            _this12._handshake().then(function () {
              if (timedout) {
                _this12.disconnect();
                return;
              }

              _this12._ws.onclose = _this12._closeHandler.bind(_this12);
              clearTimeout(timer);
              // Reset retries.
              _this12._retries = RETRIES;
              resolve(_this12);
              _this12.emit("connected");
            }, function (err) {
              reject(err);
              _this12._ws.onclose = null;
              _this12.disconnect();
            });
          };
          _this12._ws.onclose = function (e) {
            if (timedout) {
              return;
            }

            reject(new Error(errMsgFromCloseEvent(e)));
          };
          _this12._ws.onmessage = _this12._messageHandler.bind(_this12);
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _handshake: {
      value: function Handshake() /*: Promise */{
        var _this13 = this;
        this._sendMessage("auth", this._authToken);
        return this._nextMessage().then(function (msg) {
          if (msg.command !== "auth_result") {
            throw new Error("Expected \"auth_result\" command: " + msg.command);
          }
          if (msg.data !== "true") {
            _this13._authFailed = true;
            throw new Error("Failed to auth");
          }
          _this13._sendMessage("select_language", _this13._language);
          return _this13._nextMessage();
        }).then(function (msg) {
          if (msg.command !== "ready") {
            _this13._authFailed = true;
            if (msg.command === "error") {
              throw new Error(msg.data);
            }
            throw new Error("Expected \"ready\" command but got: " + msg.command);
          }

          _this13._ping();
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _sendMessage: {
      value: function SendMessage(command /*: string*/) {
        var data /*: string*/ = arguments[1] === undefined ? "" : arguments[1];
        var msg = { command: command, data: data };
        this._ws.send(JSON.stringify(msg));
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _messageHandler: {
      value: function MessageHandler(e /*: {data: string} */) {
        var msg = JSON.parse(e.data);

        if (msg.command === "pong") {
          this._ping();
          return;
        } else if (msg.command === "ping") {
          this._pong();
          return;
        } else if (msg.command === "output") {
          if (this._stdout != null) {
            this._stdout(msg.data);
          }
          return;
        }

        if (this._msgResolvers.length) {
          var resolver = this._msgResolvers.shift();
          resolver(msg);
        } else {
          this._msgQueue.push(msg);
        }
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _waitForResult: {
      value: function WaitForResult() /*: Promise*/{
        var _this14 = this;
        return this._nextMessage().then(function (msg) {
          switch (msg.command) {
            case "result":
              return msg;
            case "input":
              return _this14._waitForResult();
            case "skip":
              return { command: "result", data: "" };
              // output is handled by the message handler since it can happen
              // outside the eval loop (e.g. nodejs settimeout)
          }
          throw new Error("Unexpected command: " + msg.command);
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _closeHandler: {
      value: function CloseHandler(e /*: CloseEvent | TimeoutError */) {
        var _this15 = this;
        this._init();
        this._retries -= 1;
        clearTimeout(this._pingTimer);

        if (this._authFailed) {
          this._retries = 0;
        }

        if (this._retries < 1) {
          this.emit("disconnected", { retry: false });
          this._connecting = null;
          this._retries = 0;
          return Promise.reject(e);
        } else {
          var delay = (RETRIES - this._retries) * DELAY;
          this.emit("disconnected", { retry: true, delay: delay });
          this._connecting = new Promise(function (resolve, reject) {
            setTimeout(function () {
              return _this15._connect().then(resolve, reject);
            }, delay);
          });
          return this._connecting["catch"](function (e) {
            return _this15._closeHandler(e);
          });
        }
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _ping: {
      value: function Ping() {
        var _this16 = this;
        this._pingTimer = setTimeout(function () {
          _this16._ws.send(JSON.stringify({ command: "ping" }));
        }, 10 * 1000);
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    _pong: {
      value: function Pong() {
        this._ws.send(JSON.stringify({ command: "pong" }));
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return ReplitClient;
})(EventEmitter);




/*:: type stackRecord = { functionName: string; lineNo: number;}*/

/**
 * debug = Debugger(client);
 * debug.step().then(..) // returns {stack, done}
 * debug.result().tnen(..) // returns result
 */
var Debugger = (function () {
  /*:: _client: ReplitClient; */
  /*:: _ready: Promise<msg>; */
  /*:: _stack: Array<stackRecord> */

  function Debugger(client, code) {
    var _this17 = this;
    this._client = client;
    this._stack = [];
    if (!this._client._evalConnecting) {
      throw new Error("Expected to be connecting");
    }

    this._ready = this._client._evalConnecting.then(function () {
      _this17._client._sendMessage("debuggerStart", code);
      return _this17._client._nextMessage();
    }).then(function (msg) {
      if (msg.command !== "debuggerReady") {
        throw new Error("Expected debuggerReady message");
      }
    });
  }

  _prototypeProperties(Debugger, null, {
    step: {
      value: function step() /*: Promise<{
                                done: boolean;
                                stack: Array<stackRecord>;
                                }>*/
      {
        var _this18 = this;
        return this._ready.then(function () {
          _this18._client._sendMessage("debuggerStep");
          return _this18._client._nextMessage();
        }).then(function (msg) {
          if (msg.command !== "debuggerBreak") {
            throw new Error("Expected debuggerBreak message");
          }
          var info = JSON.parse(msg.data);
          _this18._stack = info.stack;
          return info;
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    stepOver: {
      value: function stepOver() /*: Promise<{
                                    done: boolean;
                                    stack: Array<stackRecord>;
                                    }>*/
      {
        var _this19 = this;
        if (this._stack.length === 0) {
          // First call nothing to step over.
          return this.step();
        }

        var currentStack = this._stack;
        var stepUntil = function () {
          return _this19.step().then(function (info) {
            if (info.done) {
              return info;
            }

            if (info.stack.length === currentStack.length || info.stack.length < currentStack.length) {
              return info;
            }

            return stepUntil();
          });
        };

        return stepUntil();
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    stepOut: {
      value: function stepOut() /*: Promise<{
                                   done: boolean;
                                   stack: Array<stackRecord>;
                                   }>*/
      {
        var _this20 = this;
        // Note: if this is the first call (i.e. stack.length is 0) it will step
        // through the entire program which is probably expected?
        var currentStack = this._stack;
        var stepUntil = function () {
          return _this20.step().then(function (info) {
            if (info.done) {
              return info;
            }

            if (info.stack.length < currentStack.length) {
              return info;
            }

            return stepUntil();
          });
        };

        return stepUntil();
      },
      writable: true,
      enumerable: true,
      configurable: true
    },
    result: {
      value: function result() /*: Promise<{ error: ?string; data: ?string; }>*/{
        var _this21 = this;
        return this._ready.then(function () {
          return _this21._client._nextMessage();
        }).then(function (msg) {
          if (msg.command !== "result") {
            throw new Error("Expected debuggerResult message");
          }
          return msg;
        });
      },
      writable: true,
      enumerable: true,
      configurable: true
    }
  });

  return Debugger;
})();

function errMsgFromCloseEvent(e) {
  var msg = e.reason || e.type || "";
  if (e.code) {
    msg += ": " + e.code;
  }
  return msg;
}

function TimeoutError(msg) {
  // $FlowFixMe: this is a flow bug
  Error.call(this);
  if (Error.capturStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  }

  this.name = "TimeoutError";
  this.msg = msg;
}

function HandshakeError(msg) {
  // $FlowFixMe: this is a flow bug
  Error.call(this);
  if (Error.capturStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  }

  this.name = "HandshakeError";
  this.msg = msg;
}

module.exports = ReplitClient;
/*: { stdout: ?stdout }*/
/*: { stdout: ?stdout }*/
/*: {
files: Array<file>,
suiteCode: string,
} */ /*: {
     code: string,
     suiteCode: string,
     }*/
/*: { stdout: ?stdout }*/

